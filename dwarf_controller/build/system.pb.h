// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_system_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_system_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_system_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_system_2eproto;
namespace dwarf {
class ReqClosePowerInd;
struct ReqClosePowerIndDefaultTypeInternal;
extern ReqClosePowerIndDefaultTypeInternal _ReqClosePowerInd_default_instance_;
class ReqCloseRgb;
struct ReqCloseRgbDefaultTypeInternal;
extern ReqCloseRgbDefaultTypeInternal _ReqCloseRgb_default_instance_;
class ReqOpenPowerInd;
struct ReqOpenPowerIndDefaultTypeInternal;
extern ReqOpenPowerIndDefaultTypeInternal _ReqOpenPowerInd_default_instance_;
class ReqOpenRgb;
struct ReqOpenRgbDefaultTypeInternal;
extern ReqOpenRgbDefaultTypeInternal _ReqOpenRgb_default_instance_;
class ReqPowerDown;
struct ReqPowerDownDefaultTypeInternal;
extern ReqPowerDownDefaultTypeInternal _ReqPowerDown_default_instance_;
class ReqReboot;
struct ReqRebootDefaultTypeInternal;
extern ReqRebootDefaultTypeInternal _ReqReboot_default_instance_;
class ReqSetCpuMode;
struct ReqSetCpuModeDefaultTypeInternal;
extern ReqSetCpuModeDefaultTypeInternal _ReqSetCpuMode_default_instance_;
class ReqSetMtpMode;
struct ReqSetMtpModeDefaultTypeInternal;
extern ReqSetMtpModeDefaultTypeInternal _ReqSetMtpMode_default_instance_;
class ReqSetTime;
struct ReqSetTimeDefaultTypeInternal;
extern ReqSetTimeDefaultTypeInternal _ReqSetTime_default_instance_;
class ReqSetTimezone;
struct ReqSetTimezoneDefaultTypeInternal;
extern ReqSetTimezoneDefaultTypeInternal _ReqSetTimezone_default_instance_;
class ReqsetMasterLock;
struct ReqsetMasterLockDefaultTypeInternal;
extern ReqsetMasterLockDefaultTypeInternal _ReqsetMasterLock_default_instance_;
}  // namespace dwarf
PROTOBUF_NAMESPACE_OPEN
template<> ::dwarf::ReqClosePowerInd* Arena::CreateMaybeMessage<::dwarf::ReqClosePowerInd>(Arena*);
template<> ::dwarf::ReqCloseRgb* Arena::CreateMaybeMessage<::dwarf::ReqCloseRgb>(Arena*);
template<> ::dwarf::ReqOpenPowerInd* Arena::CreateMaybeMessage<::dwarf::ReqOpenPowerInd>(Arena*);
template<> ::dwarf::ReqOpenRgb* Arena::CreateMaybeMessage<::dwarf::ReqOpenRgb>(Arena*);
template<> ::dwarf::ReqPowerDown* Arena::CreateMaybeMessage<::dwarf::ReqPowerDown>(Arena*);
template<> ::dwarf::ReqReboot* Arena::CreateMaybeMessage<::dwarf::ReqReboot>(Arena*);
template<> ::dwarf::ReqSetCpuMode* Arena::CreateMaybeMessage<::dwarf::ReqSetCpuMode>(Arena*);
template<> ::dwarf::ReqSetMtpMode* Arena::CreateMaybeMessage<::dwarf::ReqSetMtpMode>(Arena*);
template<> ::dwarf::ReqSetTime* Arena::CreateMaybeMessage<::dwarf::ReqSetTime>(Arena*);
template<> ::dwarf::ReqSetTimezone* Arena::CreateMaybeMessage<::dwarf::ReqSetTimezone>(Arena*);
template<> ::dwarf::ReqsetMasterLock* Arena::CreateMaybeMessage<::dwarf::ReqsetMasterLock>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dwarf {

// ===================================================================

class ReqSetTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dwarf.ReqSetTime) */ {
 public:
  inline ReqSetTime() : ReqSetTime(nullptr) {}
  ~ReqSetTime() override;
  explicit constexpr ReqSetTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSetTime(const ReqSetTime& from);
  ReqSetTime(ReqSetTime&& from) noexcept
    : ReqSetTime() {
    *this = ::std::move(from);
  }

  inline ReqSetTime& operator=(const ReqSetTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSetTime& operator=(ReqSetTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSetTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSetTime* internal_default_instance() {
    return reinterpret_cast<const ReqSetTime*>(
               &_ReqSetTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReqSetTime& a, ReqSetTime& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSetTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSetTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSetTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSetTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSetTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSetTime& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSetTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqSetTime";
  }
  protected:
  explicit ReqSetTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dwarf.ReqSetTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqSetTimezone final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dwarf.ReqSetTimezone) */ {
 public:
  inline ReqSetTimezone() : ReqSetTimezone(nullptr) {}
  ~ReqSetTimezone() override;
  explicit constexpr ReqSetTimezone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSetTimezone(const ReqSetTimezone& from);
  ReqSetTimezone(ReqSetTimezone&& from) noexcept
    : ReqSetTimezone() {
    *this = ::std::move(from);
  }

  inline ReqSetTimezone& operator=(const ReqSetTimezone& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSetTimezone& operator=(ReqSetTimezone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSetTimezone& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSetTimezone* internal_default_instance() {
    return reinterpret_cast<const ReqSetTimezone*>(
               &_ReqSetTimezone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReqSetTimezone& a, ReqSetTimezone& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSetTimezone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSetTimezone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSetTimezone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSetTimezone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSetTimezone& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSetTimezone& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSetTimezone* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqSetTimezone";
  }
  protected:
  explicit ReqSetTimezone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimezoneFieldNumber = 1,
  };
  // string timezone = 1;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // @@protoc_insertion_point(class_scope:dwarf.ReqSetTimezone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqSetMtpMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dwarf.ReqSetMtpMode) */ {
 public:
  inline ReqSetMtpMode() : ReqSetMtpMode(nullptr) {}
  ~ReqSetMtpMode() override;
  explicit constexpr ReqSetMtpMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSetMtpMode(const ReqSetMtpMode& from);
  ReqSetMtpMode(ReqSetMtpMode&& from) noexcept
    : ReqSetMtpMode() {
    *this = ::std::move(from);
  }

  inline ReqSetMtpMode& operator=(const ReqSetMtpMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSetMtpMode& operator=(ReqSetMtpMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSetMtpMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSetMtpMode* internal_default_instance() {
    return reinterpret_cast<const ReqSetMtpMode*>(
               &_ReqSetMtpMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReqSetMtpMode& a, ReqSetMtpMode& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSetMtpMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSetMtpMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSetMtpMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSetMtpMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSetMtpMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSetMtpMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSetMtpMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqSetMtpMode";
  }
  protected:
  explicit ReqSetMtpMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // int32 mode = 1;
  void clear_mode();
  int32_t mode() const;
  void set_mode(int32_t value);
  private:
  int32_t _internal_mode() const;
  void _internal_set_mode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dwarf.ReqSetMtpMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqSetCpuMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dwarf.ReqSetCpuMode) */ {
 public:
  inline ReqSetCpuMode() : ReqSetCpuMode(nullptr) {}
  ~ReqSetCpuMode() override;
  explicit constexpr ReqSetCpuMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSetCpuMode(const ReqSetCpuMode& from);
  ReqSetCpuMode(ReqSetCpuMode&& from) noexcept
    : ReqSetCpuMode() {
    *this = ::std::move(from);
  }

  inline ReqSetCpuMode& operator=(const ReqSetCpuMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSetCpuMode& operator=(ReqSetCpuMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSetCpuMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSetCpuMode* internal_default_instance() {
    return reinterpret_cast<const ReqSetCpuMode*>(
               &_ReqSetCpuMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReqSetCpuMode& a, ReqSetCpuMode& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSetCpuMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSetCpuMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSetCpuMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSetCpuMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSetCpuMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSetCpuMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSetCpuMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqSetCpuMode";
  }
  protected:
  explicit ReqSetCpuMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // int32 mode = 1;
  void clear_mode();
  int32_t mode() const;
  void set_mode(int32_t value);
  private:
  int32_t _internal_mode() const;
  void _internal_set_mode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dwarf.ReqSetCpuMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqsetMasterLock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dwarf.ReqsetMasterLock) */ {
 public:
  inline ReqsetMasterLock() : ReqsetMasterLock(nullptr) {}
  ~ReqsetMasterLock() override;
  explicit constexpr ReqsetMasterLock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqsetMasterLock(const ReqsetMasterLock& from);
  ReqsetMasterLock(ReqsetMasterLock&& from) noexcept
    : ReqsetMasterLock() {
    *this = ::std::move(from);
  }

  inline ReqsetMasterLock& operator=(const ReqsetMasterLock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqsetMasterLock& operator=(ReqsetMasterLock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqsetMasterLock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqsetMasterLock* internal_default_instance() {
    return reinterpret_cast<const ReqsetMasterLock*>(
               &_ReqsetMasterLock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReqsetMasterLock& a, ReqsetMasterLock& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqsetMasterLock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqsetMasterLock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqsetMasterLock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqsetMasterLock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqsetMasterLock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqsetMasterLock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqsetMasterLock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqsetMasterLock";
  }
  protected:
  explicit ReqsetMasterLock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLockFieldNumber = 1,
  };
  // bool lock = 1;
  void clear_lock();
  bool lock() const;
  void set_lock(bool value);
  private:
  bool _internal_lock() const;
  void _internal_set_lock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dwarf.ReqsetMasterLock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool lock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqOpenRgb final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dwarf.ReqOpenRgb) */ {
 public:
  inline ReqOpenRgb() : ReqOpenRgb(nullptr) {}
  explicit constexpr ReqOpenRgb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqOpenRgb(const ReqOpenRgb& from);
  ReqOpenRgb(ReqOpenRgb&& from) noexcept
    : ReqOpenRgb() {
    *this = ::std::move(from);
  }

  inline ReqOpenRgb& operator=(const ReqOpenRgb& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqOpenRgb& operator=(ReqOpenRgb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqOpenRgb& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqOpenRgb* internal_default_instance() {
    return reinterpret_cast<const ReqOpenRgb*>(
               &_ReqOpenRgb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReqOpenRgb& a, ReqOpenRgb& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqOpenRgb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqOpenRgb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqOpenRgb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqOpenRgb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqOpenRgb& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqOpenRgb& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqOpenRgb";
  }
  protected:
  explicit ReqOpenRgb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dwarf.ReqOpenRgb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqCloseRgb final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dwarf.ReqCloseRgb) */ {
 public:
  inline ReqCloseRgb() : ReqCloseRgb(nullptr) {}
  explicit constexpr ReqCloseRgb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqCloseRgb(const ReqCloseRgb& from);
  ReqCloseRgb(ReqCloseRgb&& from) noexcept
    : ReqCloseRgb() {
    *this = ::std::move(from);
  }

  inline ReqCloseRgb& operator=(const ReqCloseRgb& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqCloseRgb& operator=(ReqCloseRgb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqCloseRgb& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqCloseRgb* internal_default_instance() {
    return reinterpret_cast<const ReqCloseRgb*>(
               &_ReqCloseRgb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReqCloseRgb& a, ReqCloseRgb& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqCloseRgb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqCloseRgb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqCloseRgb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqCloseRgb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqCloseRgb& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqCloseRgb& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqCloseRgb";
  }
  protected:
  explicit ReqCloseRgb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dwarf.ReqCloseRgb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqOpenPowerInd final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dwarf.ReqOpenPowerInd) */ {
 public:
  inline ReqOpenPowerInd() : ReqOpenPowerInd(nullptr) {}
  explicit constexpr ReqOpenPowerInd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqOpenPowerInd(const ReqOpenPowerInd& from);
  ReqOpenPowerInd(ReqOpenPowerInd&& from) noexcept
    : ReqOpenPowerInd() {
    *this = ::std::move(from);
  }

  inline ReqOpenPowerInd& operator=(const ReqOpenPowerInd& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqOpenPowerInd& operator=(ReqOpenPowerInd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqOpenPowerInd& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqOpenPowerInd* internal_default_instance() {
    return reinterpret_cast<const ReqOpenPowerInd*>(
               &_ReqOpenPowerInd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReqOpenPowerInd& a, ReqOpenPowerInd& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqOpenPowerInd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqOpenPowerInd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqOpenPowerInd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqOpenPowerInd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqOpenPowerInd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqOpenPowerInd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqOpenPowerInd";
  }
  protected:
  explicit ReqOpenPowerInd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dwarf.ReqOpenPowerInd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqClosePowerInd final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dwarf.ReqClosePowerInd) */ {
 public:
  inline ReqClosePowerInd() : ReqClosePowerInd(nullptr) {}
  explicit constexpr ReqClosePowerInd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqClosePowerInd(const ReqClosePowerInd& from);
  ReqClosePowerInd(ReqClosePowerInd&& from) noexcept
    : ReqClosePowerInd() {
    *this = ::std::move(from);
  }

  inline ReqClosePowerInd& operator=(const ReqClosePowerInd& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqClosePowerInd& operator=(ReqClosePowerInd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqClosePowerInd& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqClosePowerInd* internal_default_instance() {
    return reinterpret_cast<const ReqClosePowerInd*>(
               &_ReqClosePowerInd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReqClosePowerInd& a, ReqClosePowerInd& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqClosePowerInd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqClosePowerInd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqClosePowerInd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqClosePowerInd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqClosePowerInd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqClosePowerInd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqClosePowerInd";
  }
  protected:
  explicit ReqClosePowerInd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dwarf.ReqClosePowerInd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqPowerDown final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dwarf.ReqPowerDown) */ {
 public:
  inline ReqPowerDown() : ReqPowerDown(nullptr) {}
  explicit constexpr ReqPowerDown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqPowerDown(const ReqPowerDown& from);
  ReqPowerDown(ReqPowerDown&& from) noexcept
    : ReqPowerDown() {
    *this = ::std::move(from);
  }

  inline ReqPowerDown& operator=(const ReqPowerDown& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqPowerDown& operator=(ReqPowerDown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqPowerDown& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqPowerDown* internal_default_instance() {
    return reinterpret_cast<const ReqPowerDown*>(
               &_ReqPowerDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReqPowerDown& a, ReqPowerDown& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqPowerDown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqPowerDown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqPowerDown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqPowerDown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqPowerDown& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqPowerDown& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqPowerDown";
  }
  protected:
  explicit ReqPowerDown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dwarf.ReqPowerDown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// -------------------------------------------------------------------

class ReqReboot final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dwarf.ReqReboot) */ {
 public:
  inline ReqReboot() : ReqReboot(nullptr) {}
  explicit constexpr ReqReboot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqReboot(const ReqReboot& from);
  ReqReboot(ReqReboot&& from) noexcept
    : ReqReboot() {
    *this = ::std::move(from);
  }

  inline ReqReboot& operator=(const ReqReboot& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqReboot& operator=(ReqReboot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqReboot& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqReboot* internal_default_instance() {
    return reinterpret_cast<const ReqReboot*>(
               &_ReqReboot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReqReboot& a, ReqReboot& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqReboot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqReboot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqReboot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqReboot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqReboot& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqReboot& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dwarf.ReqReboot";
  }
  protected:
  explicit ReqReboot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dwarf.ReqReboot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqSetTime

// uint64 timestamp = 1;
inline void ReqSetTime::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t ReqSetTime::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t ReqSetTime::timestamp() const {
  // @@protoc_insertion_point(field_get:dwarf.ReqSetTime.timestamp)
  return _internal_timestamp();
}
inline void ReqSetTime::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void ReqSetTime::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:dwarf.ReqSetTime.timestamp)
}

// -------------------------------------------------------------------

// ReqSetTimezone

// string timezone = 1;
inline void ReqSetTimezone::clear_timezone() {
  timezone_.ClearToEmpty();
}
inline const std::string& ReqSetTimezone::timezone() const {
  // @@protoc_insertion_point(field_get:dwarf.ReqSetTimezone.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqSetTimezone::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 timezone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dwarf.ReqSetTimezone.timezone)
}
inline std::string* ReqSetTimezone::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:dwarf.ReqSetTimezone.timezone)
  return _s;
}
inline const std::string& ReqSetTimezone::_internal_timezone() const {
  return timezone_.Get();
}
inline void ReqSetTimezone::_internal_set_timezone(const std::string& value) {
  
  timezone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReqSetTimezone::_internal_mutable_timezone() {
  
  return timezone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReqSetTimezone::release_timezone() {
  // @@protoc_insertion_point(field_release:dwarf.ReqSetTimezone.timezone)
  return timezone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReqSetTimezone::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  timezone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timezone,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timezone_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    timezone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dwarf.ReqSetTimezone.timezone)
}

// -------------------------------------------------------------------

// ReqSetMtpMode

// int32 mode = 1;
inline void ReqSetMtpMode::clear_mode() {
  mode_ = 0;
}
inline int32_t ReqSetMtpMode::_internal_mode() const {
  return mode_;
}
inline int32_t ReqSetMtpMode::mode() const {
  // @@protoc_insertion_point(field_get:dwarf.ReqSetMtpMode.mode)
  return _internal_mode();
}
inline void ReqSetMtpMode::_internal_set_mode(int32_t value) {
  
  mode_ = value;
}
inline void ReqSetMtpMode::set_mode(int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:dwarf.ReqSetMtpMode.mode)
}

// -------------------------------------------------------------------

// ReqSetCpuMode

// int32 mode = 1;
inline void ReqSetCpuMode::clear_mode() {
  mode_ = 0;
}
inline int32_t ReqSetCpuMode::_internal_mode() const {
  return mode_;
}
inline int32_t ReqSetCpuMode::mode() const {
  // @@protoc_insertion_point(field_get:dwarf.ReqSetCpuMode.mode)
  return _internal_mode();
}
inline void ReqSetCpuMode::_internal_set_mode(int32_t value) {
  
  mode_ = value;
}
inline void ReqSetCpuMode::set_mode(int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:dwarf.ReqSetCpuMode.mode)
}

// -------------------------------------------------------------------

// ReqsetMasterLock

// bool lock = 1;
inline void ReqsetMasterLock::clear_lock() {
  lock_ = false;
}
inline bool ReqsetMasterLock::_internal_lock() const {
  return lock_;
}
inline bool ReqsetMasterLock::lock() const {
  // @@protoc_insertion_point(field_get:dwarf.ReqsetMasterLock.lock)
  return _internal_lock();
}
inline void ReqsetMasterLock::_internal_set_lock(bool value) {
  
  lock_ = value;
}
inline void ReqsetMasterLock::set_lock(bool value) {
  _internal_set_lock(value);
  // @@protoc_insertion_point(field_set:dwarf.ReqsetMasterLock.lock)
}

// -------------------------------------------------------------------

// ReqOpenRgb

// -------------------------------------------------------------------

// ReqCloseRgb

// -------------------------------------------------------------------

// ReqOpenPowerInd

// -------------------------------------------------------------------

// ReqClosePowerInd

// -------------------------------------------------------------------

// ReqPowerDown

// -------------------------------------------------------------------

// ReqReboot

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dwarf

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_system_2eproto
